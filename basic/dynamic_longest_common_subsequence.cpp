//from (inflearn)영리한 프로그래밍을 위한 알고리즘 강좌 by 권오흠 교수님

#include <stdio.h>
#include <algorithm>

//최장공통부분수열(LCS)
//두 문자가 들어왔을 때 공통부분문자열의 최대길이는? (x와 y의 문자열과 lcs로서의 z 최대길이)
//만약 맨 뒤쪽의 어떤 문자가 겹친다고 했을 때 그 부분을 제외한 공통부분문자열은 x에서 해당 문자를 제외한 앞부분과 y에서 해당 문자를 제외한 앞부분의
//최대공통부분문자열이라고 할 수 있다. (최적해의 일부분이 그 부분에 대한 최적해)

//x의 길이를 i, y의 길이를 j라고 했을 때 L[i, j]는 문자열 x1~xi와 y1~yj의 LCS길이라고 하자.
//L[i, j]에 대한 순환식은 아래와 같다.
//  0 -> i가 0이거나 j가 0
//  L[i-1, j-1] + 1 -> 맨 뒷 글자가 동일한 경우
//  max(L[i-1, j], L[i, j-1]) -> 맨 뒷글자가 다른 경우 두 문자열 중 한 문자열의 맨 뒤를 버려야 하는데 뭘 버려야 할지는 명확하지 않다. 
//=> 위의 순환식 또한 general case 가 base case로 수렴한다.

int lcs(int m, int n){  //m은 x의 길이, n은 y의 길이
    int c[m+1][n+1];        //c[i][j]는 x의 i까지와 y의 j까지의 문자열 중 LCS의 길이
    for(int i = 0; i <= m; i++) c[i][0] = 0;
    for(int j = 0; j <= n; j++) c[0][j] = 0;
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            if(x[i] == y[i]) c[i][j] = c[i-1][j-1] + 1;
            else c[i][j] = std::max(c[i-1][j], c[i][j-1]);
        }
    }
    return c[m][n];
}
//시간복잡도 Θ(mn)
//문자열의 0번인덱스는 값을 비워둬야 할 듯.. 