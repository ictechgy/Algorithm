//from (inflearn)영리한 프로그래밍을 위한 알고리즘 강좌 by 권오흠 교수님

#include <stdio.h>
#include <algorithm>

//n개의 아이템과 각 아이템에 대한 무게wi와 가격Vi이 주어진다.
//배낭의 무게W도 주어지는데, 배낭의 용량을 초과하지 않고 가격이 최대가 되도록 아이템을 고른다면?
//-> greedy하게 풀수도 있긴 하다. 하지만 단순하게 무게가 작은것부터 고른다거나/가치가 큰 것부터 고른다거나/가격대비 가치가 높은 것을 고른다거나 하는
//단순한 방식으로는 답이 제대로 나오지 않을 수 있다.

//아이템 1~i로 얻을 수 있는 최대이득을 OPT(i)라고 해보자.
//i번째를 선택하지 않는 경우에는 OPT(i) = OPT(i-1)이다.
//하지만 i번째를 선택하는 경우에는 OPT(i)의 순환식을 표현할 수가 없다. 식에서 무게에 대한 값이 없기 때문에.

//따라서 무게에 대한 값을 추가하여 식을 만들어보면
//OPT(i, W): 배낭용량 W, 아이템 1 ~ i로 얻을 수 있는 최대 이득 -> 이 식은 아래와 같은 순환식을 세울 수 있다.
//  0 -> i=0인 경우. 즉 어떤 아이템도 선택하지 않는 경우 얻을 수 있는 이득은 0이다.
//  OPT(i-1, W) -> 간과해서는 안되는 부분이다. 아이템 i를 용량으로 인해 선택할 수 없을 때이다. (wi > W)
//  max(OPT(i-1, W), OPT(i-1, W-wi) + vi) -> i번째 아이템을 고르지 않는 경우와 고르는 경우 둘 중 뭐가 더 나을지 모르므로 둘 중 더 큰 값을 선택한다. 
//=> 당연히 general case가 base case로 수렴하는지도 확인해주자.

int w[6];   //1번~5번 아이템의 무게
int v[6];   //각 아이템의 가치
#define W 11     //배낭의 무게가 주어진다면
int knapsack(){   
    int M[6][W+1] = {0, };  //기본적으로 배낭의 무게가 0일때의 열에 대한 부분과 아이템을 아무것도 고르지 않는 0행부분을 0으로 초기화.
    //OPT(i)의 값은 i-1 즉 윗부분 행의 값에 의해 결정이 된다. 
    for(int i = 1; i<=6; i++){
        for(int j = 1; j <= W; j++){
            if(w[i] > j) M[i][j] = M[i-1][j];
            else M[i][j] = std::max(M[i-1][j], M[i-1][j-w[i]] + v[i]);
        }
    }
    return M[5][W];
}

//시간복잡도는 O(nW)인데, 다항시간 복잡도가 아니다. W는 개수가 아닌 값 자체이기 때문.. 
//W를 표현하기 위한 비트를 k라고 한다면 O(n2^k) 복잡도이다. -> NP-Hard