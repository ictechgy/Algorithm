#include <stdio.h>

int main(void){
    int days, n, forward, backward, a_day;
    scanf("%d %d %d", &forward, &backward, &n);
    a_day = forward - backward; //하루동안 실질적으로 올라가는 길이
    days = (n - forward + (a_day - 1))/a_day + 1;
    printf("%d\n", days);

    return 0;
}
/*
    n길이를 다 오르려면 일단 마지막 날 낮동안 올라갈 수 있는 길이를 뺀 뒤의 값을 그 이전 몇일동안 오를 수 있는지를 보면 된다. 
    다만 이 때 주의할 것은 남은 값이 하루동안 올라가게 되는 값으로 정확히 나누어진다면 문제가 없는데 그렇지 않은 경우가 있다는 것이다. 
    (나머지가 0이 아니게 나누어진다면 +1일의 시간이 추가 소요됨, 올림처리로 해도 됨)
    이를테면 19m를 올라가야하는데 낮 4m, 밤 -1m라면 하루에는 3m를 올라가는 것이고 단순히 계산하면 5일동안 15미터를 올라간 뒤 마지막날 낮에 4m를 올라가면 된다.(6일)
    하지만 18m라면 어떨까? 이는 14m를 먼저 올라가야 하는데 이는 4.666..일이 걸리고 정수만 취하면 4일, 위와 동일하게 계산하면 5일이 나온다. 하지만 답은 6일이다.
    쉽게 만들어본다면 (n-forward)/a_day + 1을 계산한 뒤에 식의 앞부분 나누기 '(n-forward)/a_day' 에서 나머지가 발생한 경우라면 1일을 더 더해주면 된다. 
    
    하지만 식을 더 간단히 해보면, 마지막날 올라가는 길이를 제외한 값을 '(n - forward + (a_day - 1))'로 설정해주면 된다.
    방법은 간단하다. n-forward를 a_day로 나누는 것은 선행되어야 하는 길이를 올라가는데 몇일이 걸리느냐를 계산하는 것이다.
    이 때 n-forward를 a_day로 나누면 나머지는 0 ~ a_day-1까지 발생하게 되는데, 나머지가 0인 경우에는 신경을 안써도 되지만 1~a_day-1의 나머지가 발생되는
    경우 추가 +1일분이 소요된다. 따라서 나머지가 1~a_day-1이 발생하는 경우에 대해 나눈 몫이 1 증가되게 해주기 위해 a_day-1을 더해준다. 이러면 기존에 나머지가
    발생되었던 경우 몫은 1이 추가되고 나머지는 0~a_day-2가 생기게 된다. 이 부분에 대해서는 신경써주지 않아주어도 된다(절삭됨)
    -> 기존에 나머지가 0이었던 경우에는 a_day-1을 더해주고 a_day로 나누어도 결과 몫에는 영향을 주지 않는다. 따라서 값이 제대로 구해진다. 
*/