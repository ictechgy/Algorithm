#include <string>
#include <vector>

using namespace std;

int solution(vector<int> priorities, int location) {
    vector<int> j_num(10, 0);  //각 중요도별 작업이 몇개있는지 체크하기 위한 배열
    //중요도는 1~9로 부여되어있으며 0번 인덱스는 사용x, 모든 인덱스 값 0값으로 초기화
    int i, cnt = 0, next_p;
    //cnt는 몇번째인지 세기위한 변수
    //next_p는 요청문서의 중요도보다 하나 높은 중요도를 가진 작업의 중요도를 의미한다. 
    for(i = 0; i < priorities.size(); i++){
        j_num[priorities[i]]++;
    }
    //인쇄의 순서는 자기보다 몇개가 우선순위가 높느냐 + 자기보다 우선순위가 하나 높은 작업 수행 이후에 
    //나와 같은 우선순위를 가진 작업이 몇개가 있느냐에 따라 결정
    for(i = j_num.size()-1; i != priorities[location]; i--){    //맨 뒤부터 읽기
        cnt += j_num[i];    //내 요청보다 우선순위가 높은 작업들의 개수 누적
    }
    for(i = priorities[location] + 1; i < j_num.size(); i++){
        if(j_num[i] != 0) {
            next_p = i;   //중요도 하나 높은 작업의 중요도를 얻음
            break;
        }
    }

    //여기까지 했다면 요청한 작업보다 몇개가 더 우선하는지를 계산 완료 및 내 요청보다 마지막으로 앞설 작업의 우선순의를 구함
    
    if(cnt == 0){   //내가 원한 작업이 가장 높은 우선순위 작업인 경우
        for(i = location - 1; i >= 0; i--){
            if(priorities[i] == priorities[location]) cnt++;
        }
        //내가 원한 작업과 동일우선순위의 작업이 앞에 몇개가 있는지 체크
    }else{  
        for(i = location - 1; priorities[i] != next_p; i--){
            if(i < 0) i = priorities.size()-1;
            if(priorities[i] == priorities[location]) cnt++;
        }
    }
    
    cnt += 1; //~ 번째이므로 자기보다 앞선 작업의 개수에 +1번째가 된다. 
    return cnt;
}

//왜 틀린 테스트 케이스가 있는걸까..? 
//고려해볼만한 상황 1. 모든 작업의 우선순위가 동일할 때 -> cnt == 0 조건에 부합
//

//queue로 구현해보자..  -> 그냥 위의 방식이 나을 것 같다.
//큐로 구현 시 가장 간단하게는 front값을 pop할 때 뒤에 우선순위가 더 높은 값이 있는지 매번 체크해서 push를 다시 할지 말지를 결정하는건데..
//pop만 수행되었을 시 cnt값을 증가시키고, 내가 요청한 작업의 위치값을 추적하는 방식으로.. 
//근데 이렇게 하면 맨 앞의 원소 하나당 뒤의 원소 n-1개를 비교해야하는거고, n이 굉장히 커지면 복잡도는 O(n^2)정도 될거같음.. 
//큐를 굳이 써야할까? 써야한다면 어떤 방식으로 쓰는게 맞는걸까..? 

//어느정도의 최적화는 할 수 있을거같은데.. 각 중요도별 작업개수를 셈한 뒤에, pop하려는 작업보다 더 큰 중요도 작업이 아직 개수가 0이 아니면
//뒤로 다시 push하고.. 높은 우선순위 작업이 없는 경우 pop만 한 뒤에 해당 우선순위 작업의 작업개수를 -1하는 방식으로. 
//이 때 우선순위가 가장 높은 작업(개수가 0이 아닌)의 우선순위를 따로 변수에 저장만 해둔다면 모든 작업을 pop할때마다 우선순위별 작업 개수 배열을
//탐색할 필요도 없을거고.. (가장 높은 우선순위 작업의 개수가 0이 되는 경우 그 밑 우선순위 작업을 찾아 해당 값으로 다시 할당하는 방식.. )